<?xml version="1.0"?>
<!DOCTYPE flagsdescription
    SYSTEM "http://www.spec.org/dtd/cpuflags2.dtd"
>

<!-- The lines above are NOT optional.  If you're adept at reading DTDs,
     the one that this file conforms to is at the URL listed above.  
     
     But most humans writing a flags file will want to have it automatically 
     checked using a validating parser such as RXP (available at
     http://www.ltg.ed.ac.uk/~richard/rxp.html), or use one of the on-line
     parsers:
       http://www.stg.brown.edu/service/xmlvalid/
       http://www.cogsci.ed.ac.uk/~richard/xml-check.html
     
     The parser used by the CPU tools is _not_ a validating parser, so it
     may be possible to sneak things by it that would not pass the checkers
     above.  However, if the checkers above say that your file is clean, it's
     clean.

     Flag files submitted to SPEC _will_ be checked by a validating parser.
     Invalid or not-well-formed flag files will be rejected.

     This file is
       Copyright (C) 2006 Standard Performance Evaluation Corporation
       All Rights Reserved
     
     This file may be freely modified and redistributed, provided that the
     copyright notice above and this notice remain unaltered.

     $Id: flags-simple.xml 4007 2006-03-17 11:34:42Z cloyce $

     **********************************************************************
     **********************************************************************
     Unless otherwise explicitly noted, all references to "section n.nn"
     refer to flag_description.html, available at

     http://www.spec.org/cpu2006/docs/flag_description.html
     **********************************************************************
     **********************************************************************

	NOTES:

		
-->
<flagsdescription>

<filename>IBM-XL.V13La</filename>

<title>IBM XL Compiler Flags and Common Unix Commands and Environment Settings</title>

<style>
<![CDATA[
body { background: white; }
]]>
</style>

<!-- =====================================================================
  Information about the meaning of fdo program options.

  They'll be appended to the end of both the flags dump and per-result flag report.

  As the contents should be HTML, it will save lots of time to just enclose
  the whole thing in a CDATA section.  Section 2.3.1 again.
     ===================================================================-->

<fdo_settings>
<![CDATA[
<ul>
<li> fdprpro -a opt -O4 -m power8 -A 2 -rcl 2 -sls -dir -vrox</li>
</ul>
<pre>

Usage:


      - First we copied the original executable (baseexe) to baseexe.orig.

      - Then, the executable is instrumented and its initial profile generated, as follows:
        $ fdprpro -a instr baseexe
        The output will be generated (by default) in baseexe.instr and its profile in baseexe.nprof.

      - Next, run baseexe.instr using the training data. This will fill the profile file with information that characterizes the training workload.

      - Finally, re-run FDPR-Pro with the profile file provided, as follows:
        $ fdprpro -a opt -f baseexe.nprof [optimization options] baseexe


fdprpro [options] -f profile program
where -f specifies the profile run data.  program is the name of the executable.
[options] can be one or more of the following:

  Action Options:

  -a/--action [action] 	Specifies customized actions
  where [action] can be one of the following:
  	anl          analyze program
  	instr        generate instrumented program for profile gathering (same as -1)
  	opt          generate optimized program (same as -3)
  	check_sign   check fdpr signature in the input program


 Action Options:     
  -anl, --analyze-program
                         Analyze the program but do not create a modified binary.
                         This option is used to generate profile/code coverage
                         reports in text format. When used with the -d option it
                         will generate the disassembly of the original program
  -cci, --code-coverage-instrumentation
                         Instrument program in order to obtain code coverage
                         information. program must be compiled with line number
                         debug info
  -pi, --profile-instrumentation
                         Instrument the program to obtain execution count profile
  -ui, --user-instrumentation
                         Instrument program by insert calls to user supplied
                         functions compiled into shared library


 Analysis Options:   
  -aawc/-noaawc, --analyze-assembly-written-csects/--noanalyze-assembly-written-csects
                         Analyze/Do not analyze objects written in Assembly.
  -acf &lt;analysis configuration file&gt;, --analysis-configuration-file &lt;analysis configuration file&gt;
                         Provide a configuration file of analysis information
                         (advanced option)
  -asd, --analyze-static-data
                         Analyze static data objects as distinct data elements
                         for data reordering (unsafe for certain compilers)
  -esa, --extra-safe-analysis
                         Limit analysis phase to compiler generated code
  -fca, --funcsect-analysis
                         Apply special analysis for an input executable that was
                         compiled with the -qfuncsect compiler option
  -ff &lt;string&gt;, --file-format &lt;string&gt;
                         Input file format: can be LM (load module) or PO
                         (program object)
  -ifl &lt;file&gt;, --ignored-function-list &lt;file&gt;
                         Set the ignored function list. The file contains names
                         of functions that considered as unsafe and thus are not
                         modified
  -iinf, --ignore-info   Ignore .info sections produced with the -qfdpr option
                         during compile time


 Instrumentation Options:
                          
  -ccl &lt;level&gt;, --code-coverage-level &lt;level&gt;
                         Perform code coverage at the basic block level (BB) or
                         at the functions level (FUNC). default is BB
  -ei, --embedded-instrumentation
                         Perform embedded instrumentation. The profile will be
                         collected into the application's global data area. When
                         the application terminates, the collected data will be
                         lost
  -fd &lt;Fdesc&gt;, --file-descriptor &lt;Fdesc&gt;
                         Set the file descriptor number to be used when opening
                         the profile file. The default of &lt;Fdesc&gt; is set to the
                         maximum-allowed number of open files
  -icsp, --instr-call-site-profiling
                         Instrument each basic block in order to collect each
                         caller context frequency
  -icvp, --instr-call-value-profiling
                         instrument the values of parameters passed in function
                         calles
  -imullX, --mullX-instrumentation
                         perform value profiling of RA and RB operands in mullX
                         instructions
  -iderat, --derat-instrumentation
                         Perform value profiling of RA and RB operands in
                         load/store indexed instructions
  -infp, --ignore-not-found-procedures
                         Ignore not found procedures defined in the
                         instrumentation directives file and do not exit with
                         error
  -ipcr/-noipcr, --instrumentation-preserve-condition-register/--noinstrumentation-preserve-condition-register
                         Preserve/Do not preserve the condition register while
                         calling stubs
  -ipctr/-noipctr, --instrumentation-preserve-count-register/--noinstrumentation-preserve-count-register
                         Preserve/Do not preserve the count register while
                         calling stubs
  -ipe/-noipe, --instrumentation-preserve-environment/--noinstrumentation-preserve-environment
                         Do not preserve registers that are not overwritten while
                         calling stubs. -noipe implies -noipvr -noipspr
  -iplr/-noiplr, --instrumentation-preserve-link-register/--noinstrumentation-preserve-link-register
                         Preserve/Do not preserve the link register while calling
                         stubs
  -ipnvr, --instrumentation-preserve-non-volatile-registers
                         Preserve the non volatile registers while calling stubs.
  -ipspr/-noipspr, --instrumentation-preserve-special-registers/--noinstrumentation-preserve-special-registers
                         Preserve/Do not preserve the special purpose registers
                         while calling stubs
  -ipvr/-noipvr, --instrumentation-preserve-volatile-registers/--noinstrumentation-preserve-volatile-registers
                         Preserve/Do not preserve the volatile registers while
                         calling stubs. -noipvr implies -noipnvr and -nosfp
  -ipxer/-noipxer, --instrumentation-preserve-fixed-point-exception-register/--noinstrumentation-preserve-fixed-point-exception-register
                         Preserve/Do not preserve the fixed-point exception
                         register while calling stubs
  -issu, --instrumentation-safe-stack-usage
                         Ensure that additional stack space is properly allocated
                         for the instrumented run. Use this option if your
                         application uses the stack extensively (e.g., when the
                         program uses alloca()). Note that this option adds
                         extra overhead on instrumentation code
  -iso &lt;offset&gt;, --instrumentation-stack-offset &lt;offset&gt;
                         Set the offset from the stack, a negative number, where
                         the instrumentation's area for saving registers is kept
                         at runtime. Use with care
  -M &lt;addr&gt;, --profile-map &lt;addr&gt;
                         Set the shared memory segment address for profiling.
                         Alternative shared memory addresses are needed when the
                         instrumented program application creates a conflict
                         with the shared-memory addresses preserved for the
                         profiling. Typical alternative values are 0x40000000,
                         0x50000000, ... up to 0xC0000000. The default is set to
                         0x3000000
  -ptm, --profile-to-memory
                         Use shared memory key instead of file mapping to obtain
                         a shared memory area for the profile data
  -ri/-nori, --register-instrumentation/--noregister-instrumentation
                         Instrument/Do not instrument the input program file to
                         collect profile information about indirect branches via
                         registers. The default is set to collect the profile
                         information
  -sfp/-nosfp, --save-floating-point-registers/--nosave-floating-point-registers
                         Save/Do not save floating point registers in
                         instrumented code. The default is set to save floating
                         point registers
  -shmkey &lt;key number&gt;, --shared-memory-key &lt;key number&gt;
                         Specify a shared memory key to use when creating a
                         shared memory area for the profile. The default key is
                         created by hashing the profile file name (with ftok).
  -spescr &lt;0-127&gt;, --spe-scratch-register &lt;0-127&gt;
                         Specify a global SPE scratch register, decreasing
                         instrumenation overhead, in order to minimize
                         possibility of local store overflow


 Profile Files Options:
                          
  -af &lt;prof_file&gt;, --ascii-profile-file &lt;prof_file&gt;
                         Set the name of a text format profile file containing
                         profile information.
  -aop, --accept-old-profile
                         Accept the old profile file collected on previous
                         versions of the input program file (requires the -f
                         flag)
  -f &lt;prof_file&gt;, --profile-file &lt;prof_file&gt;
                         Set the profile file name. The profile file is created
                         during the instrumentation phase and read during the
                         optimization phase. The profile file is updated each
                         time you run the instrumented program
  -fdir &lt;prof_file_dir&gt;, --profile-file-directory &lt;prof_file_dir&gt;
                         Set the run-time location of the profile file. The
                         profile will be search during the profiling phase at
                         this location. The default location is the path given
                         in the profile file name (-f option). Applicable only
                         at instrumentation phase


 Optimization Options:
                          
  -A &lt;alignment&gt;, --align-code &lt;alignment&gt;
                         Specify code alignment strategy. 1: Use grouping rules
                         of target machine (default), 2: Same as 1 but consider
                         also hotness of branch targets. See -m for the selected
                         machine model.
  -abb &lt;factor&gt;, --align-basic-blocks &lt;factor&gt;
                         Align basic blocks that are hotter than the average by a
                         given (float) &lt;factor&gt;. This is a lower-level
                         machine-specific alignment compared to --align-code.
                         Value of -1 (the default) disables this option
  -bh &lt;factor&gt;, --branch-hint &lt;factor&gt;
                         add branch hints to basic blocks that are hotter then
                         the average by given (float) &lt;factor&gt;. This is a SPE
                         specific optimization. Value of -1 (the default)
                         disables this option
  -ccc &lt;threshold&gt;, --cold-code-connector &lt;threshold&gt;
                         Preserves original order for code which is less
                         frequently executed than given threshold
  -bldcg, --build-dcg    Build a Data Connectivity Graph (DCG) for enhanced data
                         reordering (applicable only with the -RD flag)
  -cbpth, --cold-branch-prediction-threshold
                         Set the Cold Branch Prediction Threshold for branch
                         prediction optimization. Branches whose execution count
                         relative to the average is below this value will be
                         statically predicted. Allowed values are between (0,1).
                         Default is -1 - optimization is not applied.
                         (Applicable only with the -bp flag)
  -bpth, --branch-prediction-threshold
                         Set threshold for event based branch prediction
                         optimization
  -pbp, --preserve-branch-predication
                         Preserve branch predication pattern (bc+8) and avoid
                         code reordering and branch prediction
  -btcar, --branch-table-csect-anchor-removal
                         Eliminate load instructions used when accessing branch
                         tables
  -cbsi, --chain-based-selective-inline
                         Perform selective inlining of functions that produce
                         long hot chains of code
  -cbtd, --convert-bss-to-data
                         Convert BSS section into a data section. This is useful
                         for more aggressive tocload and RD optimizations
  -cib-opt, --convert-indirect-branches-optimization
                         Convert indirect branch to direct branch
  -cRD, --conservativeRD
                         Perform conservative static data reordering by packing
                         together all frequently referenced static variables
  -dce, --dead-code-elimination
                         Eliminate instructions related to unused local variables
                         within frequently executed functions. This is useful
                         mainly after applying function inlining optimization
  -dp, --data-prefetch   Insert data-cache prefetch instructions to improve
                         data-cache performance
  -dpht &lt;threshold&gt;, --data-placement-hotness-threshold &lt;threshold&gt;
                         Set data placement algorithm hotness threshold between
                         (0,1), where 0 reorders the static variables in large
                         groups based on the control flow, and 1 reorders the
                         variables in very small groups based on their access
                         frequency. (This is applicable only with the -RD flag)
  -dpnf &lt;factor&gt;, --data-placement-normalization-factor &lt;factor&gt;
                         Set data placement algorithm normalization factor
                         between (0,1), where 0 causes static variables to be
                         reordered regardless of their size, and 1 locates only
                         small sized variables first. (applicable only with the
                         -RD flag)
  -ece, --epilog-code-eliminate
                         Reduce code size by grouping common instructions in
                         function epilogs, into a single unified code
  -fatc &lt;num_of_bytes&gt;, --fat-const &lt;num_of_bytes&gt;
                         Inflate constant areas in code section by adding
                         &lt;num_of_bytes&gt; (entire set to 255) to each constant
                         area
  -fatd &lt;num_of_bytes&gt;, --fat-data &lt;num_of_bytes&gt;
                         Inflate data section by adding &lt;num_of_bytes&gt; (entire
                         set to 255) to each data basic unit
  -fatn &lt;num_of_nops&gt;, --fat-nop &lt;num_of_nops&gt;
                         Inflate code secion by adding &lt;num_of_nop&gt; to each code
                         basic block
  -bined &lt; binary_editor&gt;, --binary-editor &lt; binary_editor&gt;
                         Edit existing binary code (advanced option)
  -fc, --function-cloning
                         Enable function cloning phase only during function
                         inlining optimizations (applicable only with function
                         inlining flags: -i, -si, -ihf, -isf, -shci)
  -hr, --hco-reschedule  Relocate instructions from frequently executed code to
                         rarely executed code areas, when possible
  -hrf &lt;factor&gt;, --hco-resched-factor &lt;factor&gt;
                         Set the aggressiveness of the -hr optimization option
                         according to a factor value between (0,1), where 0 is
                         the least aggressive factor (applicable only with the
                         -hr option)
  -tasr, --toc-anchor-store-reschedule
                         Relocate TOC store instructions from frequently executed
                         code to rarely executed code areas, when possible
  -i, --inline           Same as --selective-inline with --inline-small-funcs 12
  -ia, --indirect-analysis
                         Perform indirect branch target analysis
  -icm-opt, --icm-optimization
                         Replace a sequence of l/ltr or ly/ltr instructions with
                         and icm or icmy instruction respectively
  -ihf &lt;pct&gt;, --inline-hot-functions &lt;pct&gt;
                         Inline all function call sites to functions that have a
                         frequency count greater than the given &lt;pct&gt; frequency
                         percentage
  -iplte, --inline-plt-entries
                         Replaces the call to a PLT entry with the PLT entry code
                         itself, by inlining the first part of the entry
  -isf &lt;size&gt;, --inline-small-funcs &lt;size&gt;
                         Inline all functions that are smaller than or equal to
                         the given &lt;size&gt; in bytes
  -kr, --killed-registers
                         Eliminate stores and restores of registers that are
                         killed (overwritten) after frequently executed function
                         calls
  -lal-opt, --load-after-load-optimization
                         Replace two load instruction from the same memory
                         location to one load instruction and one placement
                         instruction
  -lap, --load-address-propagation
                         Eliminate load instructions of variable addresses by
                         re-using pre-loaded addresses of adjacent variables
  -larl-opt, --larl-optimization
                         Replace a sequence of bras/const area/llgt instructions
                         with a single lalr instruction
  -las, --load-after-store
                         Add NOP instructions to place each load instruction
                         further apart following a store instruction that
                         references the same memory address
  -plas, --pattern-based-load-after-store
                         Optimizes inefficient memory access patterns in order to
                         avoid load-after-store events. 
  -ebplas, --event-based-pattern-based-load-after-store
                         Optimizes inefficient memory access patterns in order to
                         avoid load-after-store events. The optimization is
                         possible if PM_MRK_LSU_REJECT_LHS profile is available
  -rcl, --remove-constant-load
                         Reduces the number of load instructions used to bring
                         constant values into registers. The parameter is used
                         to control which version of optimization is applied,
                         versions from 0 to 3 are available.
  -ldce, --local-dead-code-optimization
                         Local dead code elimination (basic block scope only) -
                         needless when using -dce
  -ldp-opt, --long-displacement-optimization
                         Replace an instruction which has long displacement with
                         the matching insturction which has short displacement,
                         according to the displacement operand (e.g. ay--&gt;a,
                         oy--&gt;o, xy--&gt;x, etc.)
  -lgfr-opt, --lgfr-optimization
                         Replace when can a 32 bit instruction with its matching
                         64 bit instruction
  -llgh-opt, --llgh-optimization
                         Replace a sequence of lh/nilh/llgfr instructions with a
                         single llgh instruction
  -fce, --fix-cobol-entries
                         An optimization for COBOL code - fixes entries of
                         CSECTs. Needed for HLR optimizations.
  -pvgc &lt;mode&gt;, --print-visual-graph-csect &lt;mode&gt;
                         Print a .dot file with CFG information for each csect.
                         Mode 0 is for a graph containing full instructions list
                         for each node, 1 is for a graph with short nodes
                         description.
  -pvgf &lt;mode&gt;, --print-visual-graph-func &lt;mode&gt;
                         Print a .dot file with CFG information for each
                         function. Mode 0 is for a graph containing full
                         instructions list for each node, 1 is for a graph with
                         short nodes description.
  -lro, --link-register-optimization
                         Eliminate saves and restores of the link register in
                         frequently-executed functions
  -lu &lt;aggressiveness_factor&gt;, --loop-unroll &lt;aggressiveness_factor&gt;
                         Unroll short loops containing one to several basic
                         blocks according to an aggressiveness factor between
                         (1,9), where 1 is the least aggressive unrolling option
                         for very hot and short loops
  -lun &lt;unrolling_number&gt;, --loop-unrolling-number &lt;unrolling_number&gt;
                         Set the number of unrolled iterations in each unrolled
                         loop. The allowed range is between (2,50). Default is
                         set to 2. (Applicable only with the -lu flag)
  -lux &lt;unrolling_factor&gt;, --loop-unroll-extended &lt;unrolling_factor&gt;
                         Unroll hot loops using given unrolling factor. The
                         allowed values are integer numbers that are power of 2.
                         Value -1 disables the optimization, value 1 calculates
                         the unrolling factor automatically, given a machine
                         model
  -mvc-opt, --mvc-optimization
                         Replace an mvc instruction with lg/stg instructions
  -nillr15-opt, --nillr15-optimization
                         Remove a nill r15,0xfffe instruction if followed by an
                         stmg r14,r12,8(r13) instruction
  -sls, --store-load-on-stack-opt
                         Optimize store load on stack pattern
  -fmrx, --fmr-to-xxlor  Replace FMR instructions from reordered code with XXLOR
                         instruction
  -xscpx, --xscpsgndp-to-xxlor
                         Replace Xscpsgndp instructions from reordered code with
                         XXLOR instruction
  -dir, --dependant-instr-resched
                         Put NOP between dependant instructions
  -O                     Switch on basic optimizations only. Same as -RC -nop -bp
                         -bf
  -O2                    Switch on less aggressive optimization flags. Same as -O
                         -hr -pto -isf 8 -tlo -kr -see 0
  -O3                    Switch on aggressive optimization flags. Same as -O2 -RD
                         -isf 12 -si -lro -las -vro -btcar (for XCOFF files) -lu
                         9 -rt 0 -so -see 1 -oderat
  -O4                    Switch on aggressive optimization flags together with
                         aggressive function inlining. Same as -O3 -sidf 50 -ihf
                         20 -sdp 9 -shci 90 and -bldcg (for XCOFF files)
  -ocvp, --opt-call-value-profiling
                         specialize function calls according to the values of
                         their passed parameters
  -ocsp, --opt-call-site-profiling
                         Cluster functions with simliar behaviour according to
                         calling context 
  -omullX, --mullX-optimization
                         Optimize mullX instructions by adding a run-time check
                         on RA and RB and performing equivalent operations with
                         lower penalty. The optimization requires the use of
                         -imullX in the instrumentation phase
  -oderat, --derat-optimization
                         Optimize load/store indexed instructions by adding a
                         run-time check on RA and RB and performing equivalent
                         operations with lower penalty. The optimization
                         requires the use of -iderat in the instrumentation
                         phase
  -pbsi, --path-based-selective-inline
                         Perform selective inlining of dominant hot function
                         calls based on the control flow paths leading to hot
                         functions
  -pc, --preserve-csects
                         Preserve CSects' boundaries in reordered code
  -pca, --propagate-constant-area
                         Relocate the constant variables area to the top of the
                         code section when possible
  -pfb, --preserve-first-bb
                         Preserve original location of the entry point basic
                         block in program
  -pp, --preserve-functions
                         Preserve functions' boundaries in reordered code
  -pr/-nopr, --ptrgl-r11/--noptrgl-r11
                         Perform/Do not perform removal of R11 load instruction
                         in _ptrgl csect (the default is to perform the
                         optimization)
  -pto, --ptrgl-optimization
                         Perform optimization of indirect call instructions via
                         registers by replacing them with conditional direct
                         jumps
  -ptoht &lt;heatness_threshold&gt;, --ptrgl-optimization-heatness-threshold &lt;heatness_threshold&gt;
                         Set the frequency threshold for indirect calls that are
                         to be optimized by -pto optimization. Allowed range
                         between 0 and 1. Default is set to 0.8. (Applicable
                         only with -pto flag)
  -ptosl &lt;limit_size&gt;, --ptrgl-optimization-size-limit &lt;limit_size&gt;
                         Set the limit of the number of conditional statements
                         generated by -pto optimization. Allowed values are
                         between 1 and 100. Default value is set to 3.
                         (Applicable only with the -pto flag)
  -rcaf &lt;aggressiveness_factor&gt;, --reorder-code-aggressivenes-factor &lt;aggressiveness_factor&gt;
                         Set the aggressiveness of code reordering optimization.
                         Allowed values are [0 | 1 | 2], where 0 preserves then
                         original code order and 2 is the most aggressive.
                         Default is set to 1. (Applicable only with the -RC
                         flag)
  -rccrf &lt;reversal_factor&gt;, --reorder-code-condition-reversal-factor &lt;reversal_factor&gt;
                         Set the threshold fraction that determines when to
                         enable condition reversal for each conditional branch
                         during code reordering. Allowed input range is between
                         0.0 and 1.0 where 0.0 tries to preserve original
                         condition direction and 1.0 ignores it. Default is set
                         to 0.8 (Applicable only with the -RC flag)
  -rcctf &lt;termination_factor&gt;, --reorder-code-chain-termination-factor &lt;termination_factor&gt;
                         Set the threshold fraction that determines when to
                         terminate each chain of basic blocks during code
                         reordering. Allowed input range is between 0.0 and 1.0
                         where 0.0 generates long chains and 1.0 creates single
                         basic block chains. Default is set to 0.05. (Applicable
                         only with the -RC flag)
  -RD, --reorder-data    Perform static data reordering
  -ippcf, --instrument-for-path-profiling
                         Perform cross function path profiling instrumentation
  -ppcf, --optimize-with-path-profiling
                         Perform cross function path profiling optimization
  -rmte, --remove-multiple-toc-entries
                         Remove multiple TOC entries pointing to the same
                         location in the input program file
  -rt &lt;removal_factor&gt;, --reduce-toc &lt;removal_factor&gt;
                         Perform removal of TOC entries according to a removal
                         factor between (0,1), where 0 removes non-accessed TOC
                         entries only and 1 removes all possible TOC entries
  -rtb, --remove-traceback-tables
                         Remove traceback tables in reordered code
  -rcs, --remove-csect-symbols
                         Remove csect symbols
  -sal-opt, --store-after-load-optimization
                         Remove store after load when there is no change
  -scca &lt;level&gt;, --safe-calling-conventions-analysis &lt;level&gt;
                         Determine how conservative must FDPR be when analysing a
                         function that may break calling conventions
  -sdp &lt;aggressiveness_factor&gt;, --stride-data-prefetch &lt;aggressiveness_factor&gt;
                         Perform data prefetching within frequently executed
                         loops based on stride analysis, according to an
                         aggressiveness factor between (1,9), where 1 is the
                         least aggressive
  -sdpila &lt;instructions_number&gt;, --stride-data-prefetch-instruction-look-ahead &lt;instructions_number&gt;
                         Set the number of instructions for which data is
                         prefetched into the cache ahead of time. Default value
                         is platform dependant. (Applicable only with the -sdp
                         flag)
  -sdpms &lt;stride_min_size&gt;, --stride-data-prefetch-min-size &lt;stride_min_size&gt;
                         Set the minimal stride size in bytes, for which data
                         will be considered a candidate for prefetching. Default
                         value is set to 128 bytes. (Applicable only with the
                         -sdp flag)
  -ebp &lt;evt_based_prefetch&gt;, --event-based-prefetch &lt;evt_based_prefetch&gt;
                         Perform data prefetching based on the events file
  -ebpla &lt;instructions_number&gt;, --event-based-prefetch-look-ahead &lt;instructions_number&gt;
                         Set the number of instructions for which event based
                         prefetch is performed. Default value is platform
                         dependant. (Applicable only with the -ebp flag)
  -see &lt;level&gt;           Use simplified prolog/epilog for functions that perform
                         conditional early-exit. Use basic optimization with
                         &lt;level&gt;=0 and maximal with &lt;level&gt;=1
  -shci &lt;pct&gt;, --selective-hot-code-inline &lt;pct&gt;
                         Perform selective inlining of functions in order to
                         decrease the total number of execution counts, so that
                         only functions with hotness above the given percentage
                         are inlined
  -si, --selective-inline
                         Perform selective inlining of dominant hot function
                         calls
  -sidf &lt;percentage_factor&gt;, --selective-inline-dominant-factor &lt;percentage_factor&gt;
                         Set a dominant factor percentage for selective inline
                         optimization. The allowed range is between 0 and 100.
                         Default is set to 80. (Applicable only with the -si and
                         -pbsi flags)
  -siht &lt;frequency_factor&gt;, --selective-inline-hotness-threshold &lt;frequency_factor&gt;
                         Set a hotness threshold factor percentage for selective
                         inline optimization to inline all dominant function
                         calls that have a frequency count greater than the
                         given frequency percentage. Default is set to 100.
                         (Applicable only with the -si -pbsi flags)
  -slbp, --spinlock-branch-prediction
                         Perform branch prediction bit setting for conditional
                         branches in spinlock code containing l*arx and st*cx
                         instructions. (Applicable after -bp flag)
  -sldp, --spinlock-data-prefetch
                         Perform data prefetching for memory access instructions
                         preceding spinlock code containing l*arx and st*cx
                         instructions
  -sll &lt;Lib1:Prof1,...,LibN:ProfN&gt;, --static-link-libraries &lt;Lib1:Prof1,...,LibN:ProfN&gt;
                         Statically link hot code from specified dynamically
                         linked libraries to the input program. The parameter
                         consists of a comma-separated list of libraries and
                         their profiles. IMPORTANT: Licensing rights of
                         specified libraries should be observed when applying
                         this copying optimization
  -sllht &lt;hotness_threshold&gt;, --static-link-libraries-hotness-threshold &lt;hotness_threshold&gt;
                         Set hotness threshold for the --static-link-libraries
                         optimization. The allowed input range is between 0
                         (least aggressive) and 1, or -1, which does not require
                         a profile and selects all code that might be called by
                         the input program from the given libraries. Default is
                         set at 0.5
  -so, --stack-optimization
                         Reduce the stack frame size of functions that are called
                         with a small number of arguments
  -spc, --shortcut-plt-calls
                         Shortcut PLT calls in shared libraries to local
                         functions if they exist. Note: Resolving to external
                         symbols is disabled for such calls
  -stf, --stack-flattening
                         Merge the stack frames of inlined functions with the
                         frames of the calling functions
  -tb, --preserve-traceback-tables
                         Force the restructuring of traceback tables in reordered
                         code. If -tb option is omitted, traceback tables are
                         automatically included only for C++ applications that
                         use the Try &amp; Catch mechanism
  -tlo, --tocload-optimization
                         Replace each load instruction that references the TOC
                         with a corresponding add-immediate instruction via the
                         TOC anchor register, where possible
  -ucde, --unreachable-code-data-elimination
                         Remove unreachable code and non-accessed static data
  -vro, --volatile-registers-optimization
                         Eliminate stores and restores of non-volatile registers
                         in frequently executed functions by using available
                         volatile registers
  -vrox, --volatile-registers-extended-optimization
                         Eliminate stores and restores of non-volatile registers
                         in frequently executed functions by using available
                         volatile registers, the extended version supports FP
                         registers and transparency


 Output Options:     
  -bcdf &lt;file&gt;, --binary-code-dump-file &lt;file&gt;
                         Create a binary dump of the code (opcodes) with
                         annotations of addresses.
  -ccgi &lt;mode&gt;, --code-coverage-generate-info &lt;mode&gt;
                         Produce coverage information in a file based on profile
                         information. Use &lt;mode&gt;=XML for an XML output and
                         &lt;mode&gt;=FLAT for a formatted text file. The generated
                         file is &lt;output file&gt;.cci[.xml]
  -cep, --complement-edge-profile
                         Complements partial profile information given for the
                         basic blocks' frequencies by adding missing basic
                         block-to-basic block edge counts
  -d, --disassemble-text
                         Print the disassembled text section of the output
                         program into &lt;output_file&gt;.dis_text file
  -dap, --dump-ascii-profile
                         Dump profile information in ASCII format into
                         &lt;program&gt;.aprof (requires the -f flag).
  -db, --disassemble-bss
                         Print the disassembled bss section of the output program
                         into &lt;output_file&gt;.dis_bss file
  -dd, --disassemble-data
                         Print the disassembled data section of the output
                         program into &lt;output_file&gt;.dis_data file
  -diap, --dump-initial-ascii-profile
                         Dump the given profile information in ASCII format into
                         &lt;program&gt;.aprof.init (requires the -f flag)
  -dim, --dump-instruction-mix
                         Dump instruction mix statistics based on gathered
                         profile information
  -dm, --dump-mapper     Print a map of basic blocks and static variables with
                         their respective new -&gt; old addresses into a
                         &lt;program&gt;.mapper file
  -enc, --encapsulate    Encapsulate SPE executables present in the PPE input
                         (see --spe-directory)
  -o &lt;output_file&gt;, --output-file &lt;output_file&gt;
                         Set the name of the output file. The default
                         instrumented file is &lt;program&gt;.instr. The default
                         optimized file is &lt;program&gt;.fdpr
  -scl, --show-constant-load
                         Adds annotaions in fdpr disassembly on load instructions
                         used to bring constant values into registers (requires
                         -d flag)
  -pds, --preserve-debug-symbols
                         Preserve debug symbols
  -plc, --preserve-linkage-conventions
                         Preserve linkage conventions
  -ppcf, --print-prof-counts-file
                         Print a text format of the profiling counters into a
                         &lt;program&gt;.counts file (requires the -f flag).
  -sf, --strip-file      Strip the output file
  -simo, --single-input-multiple-outputs
                         Optimize in parallel into multiple outputs as specified
                         by option sets read from stdin
  -spedir &lt;directory&gt;, --spe-directory &lt;directory&gt;
                         Set the directory into which SPE executables will be
                         extracted and from which they will be encapsulated


 General Options:    
  -cell, --cell-supervisor
                         Integrated PPE/SPE processing. Perform SPE extraction,
                         processing, and encapsulation automatically prior to
                         PPE processing
  -h, --help             Print the online help
  -j &lt;jour_file&gt;, --journal &lt;jour_file&gt;
                         Output optimization journal information to &lt;jour_file&gt;
  -smt, --smt_mode       set SMT mode (1:ST, 2: (SMT2-shared, SMT2-split),
                         4:SMT4, 8:SMT8)
  -m &lt;machine-model&gt;, --machine &lt;machine-model&gt;
                         Generate code for the specified machine model. Target
                         machine can be one of the following models: power2,
                         power3, ppc405, ppc440, power4, ppc970, power5, power6,
                         power7, power8, ppe, spe, spe_edp, z10, z9.
                         Default is power7
  -q, --quiet            Set the output mode to quiet, suppressing informational
                         messages
  -st &lt;stat_file&gt;, --statistics &lt;stat_file&gt;
                         Output statistics information to &lt;stat_file&gt;. If
                         &lt;stat_file&gt; is '-', the output goes to the standard
                         output. See --verbose for the default
  -v &lt;level&gt;, --verbose &lt;level&gt;
                         Set verbose output mode level. When set, various
                         statistics about the output program are printed into
                         the file &lt;program&gt;.stat. Allowed level range is between
                         0 and 3. Default is set to 0
  -V, --version          Print the version number
  -w &lt;level&gt;, --warning-level &lt;level&gt;
                         Set the warning level so only errors of this level and
                         below will be printed. The levels are: 1: errors, 2:
                         warnings, 3: debug warning, 4: debug information.
                         Default is 2
  -armember              For archive files - list of archive members to be
                         optimized, if -armember is not specified, all members
                         will be optimized
</pre>
]]>
</fdo_settings>

<!-- =====================================================================
  The <header> section is also entirely optional.  If it is provided, and
  no class is specified, then it will be inserted verbatim at the top
  of the flags dump.

  If a class is specified, that text will be inserted verbatim before flags
  of that class.  
  
  As the contents should be HTML, it will save lots of time to just enclose
  the whole thing in a CDATA section.  Section 2.3.1 again.
     ===================================================================-->
<header>
<![CDATA[
<p>Compilers: IBM XL C/C++ Version 13.1 for Linux</p>
<p>Compilers: IBM XL Fortran Version 15.1 for Linux</p>
<p>Libraries: IBM IBM Advance Toolchain 7</p>
<p>Operating systems: Red Hat Enterprise Linux Server release 7 </p>
<p>Last updated: 16-June-2014</p> ]]>
</header>

<!--
  -
  -	Compiler declarations.
  -
  -
  -->

<flag
      name="xlc"
      class="compiler"
      regexp="(\S*\/)?xlc_at(_r)?\b">
<example>
xlc,
xlc_r
</example>
<![CDATA[
<p>
Invoke the IBM XL C compiler. 32-bit binaries are produced by default.
Link with the IBM Advanced Toolchain libraries.
</p>
]]>
</flag>


<flag
      name="xlC"
      class="compiler"
      regexp="(\S*\/)?xlC_at(_r)?\b">
<example>
xlC,
xlC_r
</example>
<![CDATA[
<p>
Invoke the IBM XL C++ compiler. 32-bit binaries are produced by default.
Link with the IBM Advanced Toolchain libraries.
</p>
]]>
</flag>


<flag
      name="xlf95"
      class="compiler"
      regexp="(\S*\/)?xlf95_at(_r)?\b">
<example>
xlf95,
xlf95_r
</example>
<![CDATA[
<p>
Invoke the IBM XL Fortran compiler. 32-bit binaries are produced by default.
Link with the IBM Advanced Toolchain libraries.
</p>
]]>
</flag>


<!--
  -
  -	Aggregated optimization flags.
  -
  -->

<flag name="F-O5"
      class="optimization"
      regexp="-O5\b">
<example>
-O5
</example>
<![CDATA[
<p>
Perform optimizations for maximum performance. This includes maximum
interprocedural analysis on all of the objects presented on the "link" 
step. This level of optimization will increase the compiler's memory
usage and compile time requirements. -O5 Provides all of the functionality
of the -O4 option, but also provides the functionality of the
-qipa=level=2 option.
</p>

-O5 is equivalent to the following flags
<ul>
  <li> <tt>-O4</tt> </li>
  <li> <tt>-qipa=level=2</tt> </li>
</ul>
]]>
<include flag="F-O4" />
<include flag="F-qipa:level" flagtext="-qipa=level=2" />
</flag>


<flag name="F-O4"
      class="optimization"
      regexp="-O4\b">
<example>
-O4
</example>
<![CDATA[
<p>
Perform optimizations for maximum performance. This includes
interprocedural analysis on all of the objects presented on the "link" 
step.
</p>

-O4 is equivalent to the following flags
<ul>
  <li> <tt>-O3</tt> </li>
  <li> <tt>-qipa=level=1</tt> </li>
  <li> <tt>-qarch=auto</tt> </li>
  <li> <tt>-qtune=auto</tt> </li>
  <li> <tt>-qsimd=auto</tt> </li>
</ul>
]]>
<include flag="F-O3" />
<include flag="F-qipa:level" flagtext="-qipa=level=1" />
<include flag="F-qarch" flagtext="-qarch=auto" />
<include flag="F-qtune" flagtext="-qtune=auto" />
<include flag="F-qsimd" flagtext="-qsimd=auto" />
</flag>


<flag name="F-O3"
      class="optimization"
      regexp="-O3\b">
<example>-O3</example>
<![CDATA[
-O3 Performs additional optimizations that are memory intensive, compile-time
intensive, and may change the semantics of the program slightly, unless
-qstrict is specified. We recommend these optimizations when the desire for
run-time speed improvements outweighs the concern for limiting compile-time
resources. The optimizations provided include:
<ul>
  <li> In-depth memory access analysis </li>
  <li> Better loop scheduling </li>
  <li> High-order loop analysis and transformations (-qhot=level=0) </li>
  <li> Inlining of small procedures within a compilation unit by default </li>
  <li> Eliminating implicit compile-time memory usage limits </li>
  <li> Widening, which merges adjacent load/stores and other operations </li>
  <li> Pointer aliasing improvements to enhance other optimizations </li>
</ul>

-O3 is equivalent to the following flags
<ul>
  <li> <tt>-O2</tt> </li>
  <li> <tt>-qhot=level=0</tt> </li>
</ul>
]]>
<include flag="F-O2" />
<include flag="F-qhot" flagtext="-qhot=level=0" />
</flag>


<flag name="F-O2"
      class="optimization"
      regexp="-O2\b">
<example>-O2</example>
<![CDATA[
-O2 Performs a set of optimizations that are intended to offer improved
performance without an unreasonable increase in time or storage that is
required for compilation including:
<ul>
  <li> Eliminates redundant code </li>
  <li> Basic loop optimization </li>
  <li> Can structure code to take advantage of -qarch and -qtune settings </li>
</ul>
]]>
<include flag="F-O" />
</flag>


<flag name="F-O"
      class="optimization"
      regexp="-O\b">
<example>-O</example>
<![CDATA[
-O enables the level of optimization that represents the best tradeoff
between compilation speed and run-time performance.
If you need a specific level of optimization, specify the appropriate
numeric value. 
Currently, -O is equivalent to -O2.
]]>
<include flag="F-O2" />
</flag>



<!--
  -
  -	Optimization flags: individual methods.
  -
  -->

<flag name="F-qarch"
      class="optimization"
      regexp="-qarch=(\S+)\b">
<example>-qarch</example>
<![CDATA[
<p>
Produces object code containing instructions that will run on the
specified processors. "auto" selects the processor the compile
is being done on. "pwr5x" is the POWER5+ processor.
</p>

<p>Supported values for this flag are</p>
<ul>
  <li>auto	- Use the processor on which the program is compiled.</li>
  <li>pwr8	- The POWER8 processor based systems.</li>
  <li>pwr7	- The POWER7 processor based systems.</li>
  <li>pwr6e	- The POWER6 processor in "Enhanced" mode based systems.</li>
  <li>pwr6	- The POWER6 processor based systems.</li>
  <li>pwr5x	- The POWER5+ processor based systems.</li>
  <li>pwr5	- The POWER5 processor based systems.</li>
  <li>pwr4	- The POWER4 processor based systems.</li>
  <li>ppc970	- The PPC970 processor based systems.</li>
</ul>
]]>
</flag>


<flag name="F-qtune"
      class="optimization"
      regexp="-qtune=(\S+)\b">
<example>-qtune</example>
<![CDATA[
<p>
Specifies the system architecture for which the executable program
is optimized.  This includes instruction scheduling and cache setting.
</p>

<p>The supported values for <tt>suboption</tt> are</p>
<ul>
  <li>auto	- Use the processor on which the program is compiled.</li>
  <li>pwr8	- The POWER8 processor based systems.</li>
  <li>pwr7	- The POWER7 processor based systems.</li>
  <li>pwr6e	- The POWER6 processor in "Enhanced" mode based systems.</li>
  <li>pwr6	- The POWER6 processor based systems.</li>
  <li>pwr5x	- The POWER5+ processor based systems.</li>
  <li>pwr5	- The POWER5 processor based systems.</li>
  <li>pwr4	- The POWER4 processor based systems.</li>
  <li>ppc970	- The PPC970 processor based systems.</li>
</ul>
]]>
</flag>


<flag name="F-qnoinline"
      class="optimization"
      regexp="-qnoinline\b">
This option specifies that no functions are to be inlined.
</flag>


<flag name="F-qinlglue"
      class="optimization"
      regexp="-qinlglue\b">
This option inlines glue code that optimizes external
function calls when compiling.
</flag>

<flag name="F-qlargepage"
      class="optimization"
      regexp="-qlargepage\b">
This option optimizes applications to use large/huge pages.
</flag>


<flag name="F-qufmt"
      class="optimization"
	regexp="-qufmt(=be|=le)\b">

<![CDATA[
<p>
Sets the byte order for I/O operations on unformatted data
files. <suboption> must be one of the following suboptions:
</p>
<p>
                be   :
                     Specifies that I/O operations on unformatted data files use
                     big-endian byte order.
</p>
<p>
                le   :
                     Specifies that I/O operations on unformatted data files use
                     little-endian byte order.
</p>
<p>
                Default: -qufmt=le
</p>
]]>

</flag>

<flag name="F-qspill"
	class="optimization"
	 regexp="-qspill(=[0-9]*)\b">
Specifies the size of the register allocation spill area in bytes.
</flag>


<flag name="F-qhot"
      class="optimization"
      regexp="-qhot(=arraypad|=simd|=(no)?vector|=level=[01])?\b">
<example>
-qhot,
-qhot=level=1,
-qhot=simd
-qhot=novector
</example>
<![CDATA[
<p>
Performs high-order transformations on loops during optimization.
The supported values for <tt>suboption</tt> are:
</p>
<ul>
   <li>arraypad - The compiler will pad any arrays where it infers that there may be a benefit.</li>
   <li>level=0  - The compiler performs a limited set of high-order loop transformations.</li>
   <li>level=1  - The compiler performs its full set of high-order loop transformations.</li>
   <li>simd     - Replaces certain instruction sequences with vector instructions.</li>
   <li>vector   - Replaces certain instruction sequences with calls to the MASS library.</li>
</ul>
<p>
Specifying -qhot without suboptions implies -qhot=nosimd, -qhot=noarraypad, -qhot=vector and
-qhot=level=1. The -qhot option is also implied by -O4, and -O5.
</p>
]]>
</flag>


<flag name="F-qipa:level"
      class="optimization"
      regexp="-qipa=level=[012]\b">
<example>
-qipa=level
</example>
<![CDATA[
<p>
Enhances optimization by doing detailed analysis across procedures
(interprocedural analysis or IPA). 
The <tt>level</tt> determines the amount of interprocedural analysis
and optimization that is performed.
</p>

<p>
  <tt>level=0</tt> Does only minimal interprocedural analysis and optimization
</p>

<p>
  <tt>level=1</tt> turns on inlining , limited alias analysis, and limited
  call-site tailoring
</p>

<p>
  <tt>level=2</tt> turns on full interprocedural data flow and alias analysis
</p>
]]>
</flag>


<flag name="F-qnoipa"
      class="optimization"
      regexp="-qnoipa\b">
<![CDATA[
<p>
Suppresses interprocedural analysis (IPA), which is enabled by default
at optimization levels -O4 and -O5.
</p>
]]>
</flag>


<flag name="F-qpdf1"
      class="optimization"
      regexp="-qpdf1\b">
The option used in the first pass of a profile directed feedback compile
that causes pdf information to be generated.
The profile directed feedback optimization gathers data on both execution
path and data values. It does not use hardware counters, nor gather any
data other than path and data values for PDF specific optimizations.
</flag>


<flag name="F-qpdf2"
      class="optimization"
      regexp="-qpdf2\b">
The option used in the second pass of a profile directed feedback compile
that causes PDF information to be utilized during optimization.
</flag>


<flag name="F-qfdpr"
      class="optimization"
      regexp="-qfdpr\b">
The compiler generates additional symbol information for use by the "fdpr"
binary optimization tool.
</flag>


<flag name="F-qnothreaded"
      class="optimization"
      regexp="-qnothreaded\b">
Do not use the XL compiler thread information.
</flag>


<flag name="F-qnoxlcompatmacros"
      class="optimization"
      regexp="-qnoxlcompatmacros\b">
Do not use the XL compiler compat macros.
</flag>


<flag name="F-qxlf90"
      class="optimization"
      regexp="-qxlf90=(signedzero|nosignedzero|autodealloc|noautodealloc|oldpad|nooldpad|)\b">
<example>
-qxlf90=nosignedzero
</example>
<![CDATA[
<pre>
         -qxlf90=&lt;suboption&gt;
                Determines whether the compiler provides the
                Fortran 90 or the Fortran 95 level of support for
                certain aspects of the language. &lt;suboption&gt; can be
                one of the following:

                signedzero | nosignedzero
                     Determines how the SIGN(A,B) function handles
                     signed real 0.0. In addition, determines
                     whether negative internal values will be
                     prefixed with a minus when formatted output
                     would produce a negative sign zero.
                autodealloc | noautodealloc
                     Determines whether the compiler deallocates
                     allocatable arrays that are declared locally
                     without either the SAVE or the STATIC
                     attribute and have a status of currently
                     allocated when the subprogram terminates.
                oldpad | nooldpad
                     When the PAD=specifier is present in the
                     INQUIRE statement, specifying -qxlf90=nooldpad
                     returns UNDEFINED when there is no connection,
                     or when the connection is for unformatted I/O.
                     This behavior conforms with the Fortran 95
                     standard and above. Specifying -qxlf90=oldpad
                     preserves the Fortran 90 behavior.

                Default:
                     o signedzero, autodealloc and nooldpad for the
                     xlf95, xlf95_r, xlf95_r7 and f95 invocation
                     commands.
                     o nosignedzero, noautodealloc and oldpad for
                     all other invocation commands.
</pre>
]]>
</flag>



<!--
  -
  -	Optimization flags: memory allocation.
  -
  -->

<flag name="F-q64"
      class="optimization"
      regexp="-q64\b">
<example>
-q64
</example>
Generates 64 bit ABI binaries. The default is to generate 32 bit ABI binaries.
</flag>

<!-- qlargepage and qalloca are not supported on LE
<flag name="F-qlargepage"
      class="optimization"
      regexp="-qlargepage\b">
Indicates that a program, designed to execute in a 
large page memory environment, can take advantage 
of large 16 MB pages provided on POWER4 and higher 
based systems.
</flag>


<flag name="F-qalloca"
      class="optimization"
      regexp="-qalloca\b">
Indicates that the compiler understands how to do alloca().
</flag>
-->

<flag name="F-qsmallstack:dynlenonheap"
      class="optimization"
      regexp="-qsmallstack=dynlenonheap\b">
Causes the Fortran compiler to allocate dynamic arrays on the heap instead
of the stack
</flag>


<flag name="F-qsave"
      class="optimization"
      regexp="-qsave\b">
Specifies that all local variables be treated as STATIC.
</flag>



<!--
  -
  -	Optimization flags: vector calculations.
  -
  -->

<flag name="F-qsimd"
      class="optimization"
      regexp="-q(no)?simd(=auto|=noauto)?\b">
<example>
-qsimd
-qnosimd
-qsimd=noauto
</example>
Enables the generation of vector instructions for processors
that support them.
</flag>

<flag name="F-qenablevmx"
      class="optimization"
      regexp="-q(no)?enablevmx\b">
<example>
-qenablevmx
-qnoenablevmx
</example>
Enables the generation of vector instructions for processors
that support them.
</flag>


<flag name="F-qvecnvol"
      class="optimization"
      regexp="-qvecnvol\b">
Specifies whether to use volatile or non-volatile vector
registers. Volatile vector registers are registers whose
value is not preserved across function calls so the 
compiler will not depend on values in them across function
calls.
</flag>



<!--
  -
  -	Optimization flags: support libraries.
  -
  -->

<flag name="F-lmass"
      class="optimization"
      regexp="-lmass\b">
Link the mathematical acceleration subsystem libraries (MASS),
which contain libraries of tuned mathematical intrinsic
functions.
</flag>


<flag name="F-lessl"
      class="optimization"
      regexp="-lessl\b">
Link the Engineering and Scientific Subroutine Library (ESSL).
</flag>


<flag name="F-qessl"
      class="optimization"
      regexp="-qessl\b">
Specifies that, if either -lessl or -lesslsmp are also
specified, then Engineering and Scientific Subroutine Library
(ESSL) routines should be used in place of some Fortran 90
intrinsic procedures when there is a safe opportunity to do so.
</flag>


<!--
  -
  -	Mixed: Semantic compliance issues.
  -
  -->

<flag name="F-qrtti"
      class="optimization"
      regexp="-qrtti\b">
Cause the C++ compiler to generate Run Time Type Identification code
</flag>


<flag name="F-qchars:signed"
      class="portability"
      regexp="-qchars=signed\b">
Causes the compiler to treat "char" variables as signed instead of the
default of unsigned.
</flag>


<!--
  -
  -	Portability flags: syntactic compliance.
  -
  -->

<flag name="F-qfixed"
      class="portability"
      regexp="-qfixed\b">
Indicates that the input fortran source program is in fixed form.
</flag>


<flag name="F-qextname"
      class="portability"
      regexp="-qextname\b">
Adds an underscore to global entities to match the C compiler ABI
</flag>


<flag name="F-qcpluscmt"
      class="portability"
      regexp="-qcpluscmt\b">
<example>
-qcpluscmt
</example>
<![CDATA[
<p>
 Permits the usage of "//" to introduce a comment
 that lasts until the end of the current source
 line, as in C++.
</p>
]]>
</flag>


<!--
  -
  -	Other flags: optimizations and non-compliant code.
  -
  -->

<flag name="F-qalias"
      class="optimization"
      regexp="-qalias=(noansi|nostd)\b">
<example>
-qalias=noansi,
-qalias=nostd
</example>
<![CDATA[
<pre>
 qalias=ansi | noansi
   If ansi is specified, type-based aliasing is
   used during optimization, which restricts the
   lvalues that can be safely used to access a
   data object. The default is ansi for the xlc,
   xlC, and c89 commands. This option has no
   effect unless you also specify the -O option.

 qalias=std |nostd
   Indicates whether the compilation units contain
   any non-standard aliasing (see Compiler Reference
   for more information). If so, specify nostd. 
</pre>
]]>
</flag>


<flag name="F-qalign"
      class="optimization"
      regexp="-qalign=(\S+)\b">
<example>
-qalign=natural
</example>
<![CDATA[
<pre>
           Specifies what aggregate alignment rules the
                compiler uses for file compilation, where the
                alignment options are:

                bit_packed
                     The compiler uses the bit_packed alignment
                     rules.
                full
                     The compiler uses the RISC System/6000
                     alignment rules. This is the same as power.
                mac68k
                     The compiler uses the Macintosh alignment
                     rules.  This suboption is valid only for 32-
                     bit compilations.
                natural
                     The compiler maps structure members to their
                     natural boundaries.
                packed
                     The compiler uses the packed alignment rules.
                power
                     The compiler uses the RISC System/6000
                     alignment rules.
                twobyte
                     The compiler uses the Macintosh alignment
                     rules.  This suboption is valid only for 32-
                     bit compilations.  The mac68k option is the
                     same as twobyte.

                The default is -qalign=full.
</pre>
]]>
</flag>


<flag name="F-qassert"
      class="optimization"
      regexp="-qassert=(refalign|contiguous)?\b">
<example>
-qassert=refalign
-qassert=contig
</example>
<![CDATA[
<pre>
 qassert=refalign | norefalign | contig
   <tt>refalign</tt> specifies that all pointers inside the compilation
   unit only point to data that is naturally aligned
   according to the length of the pointer types.

   <tt>contig</tt> specifies the compiler can perform optimizations
   according to the memory layout of the objects occupying
   contiguous blocks of memory.
</pre>
]]>
</flag>

<flag name="F-qprefetch:aggresive"
      class="optimization"
      regexp="-qprefetch=aggressive\b">
<example>
-qprefetch=aggressive
</example>
<![CDATA[
<pre>
 qprefetch=aggressive
   Aggressively prefetch data
</pre>
]]>
</flag>

<flag name="F-qprefetch:dscr"
      class="optimization"
      regexp="-qprefetch=dscr=(\S+)\b">
<example>
-qprefetch=dscr=42
</example>
<![CDATA[
<p>
 The <tt>prefetch=dscr</tt> option causes the
   Data Streams Control Register to be set to the value
   specified when executing this program.
</p>
]]>
</flag>

<flag name="F-qnoprefetch"
      class="optimization"
      regexp="-qnoprefetch\b">
<example>
-qnoprefetch
</example>
<![CDATA[
<p>
 The <tt>noprefetch</tt> option causes the
   compiler to generate no prefetch instructions
   and to not adjust the DSCR when executing this program.
</p>
]]>
</flag>

<flag name="F-qrestrict"
      class="optimization"
      regexp="-qrestrict\b">
<example>
-qrestrict
</example>
<![CDATA[
<pre>
 qrestrict
   TBD
</pre>
]]>
</flag>

<flag name="F-qsmp:auto"
      class="optimization"
      parallel="yes"
      regexp="-qsmp=auto\b">
Causes the compiler to automatically generate parallel code using
OMP controls when possible.
</flag>


<flag name="F-qsmp:omp"
      class="optimization"
      parallel="yes"
      regexp="-qsmp=omp\b">
Tell the compiler that OMP controls are used to identify parallel code.
</flag>


<flag name="F-qstrict"
      class="optimization"
      regexp="-q(no)?strict\b">
<example>
-qstrict,
-qnostrict
</example>
<![CDATA[
<pre>
                Ensures that optimizations done by default at
                optimization levels -O3 and higher, and, optionally
                at -O2, do not alter the semantics of a program.

                The -qstrict=all, -qstrict=precision,
                -qstrict=exceptions, -qstrict=ieeefp, and
                -qstrict=order suboptions and their negative forms
                are group suboptions that affect multiple,
                individual suboptions. Group suboptions act as if
                either the positive or the no form of every
                suboption of the group is specified.

                Default:

                     o Always -qstrict or -qstrict=all when the
                     -qnoopt or -O0 optimization level is in effect
                     o -qstrict or -qstrict=all is the default when
                     the -O2 or -O optimization level is in effect
                     o -qnostrict or -qstrict=none is the default
                     when -O3 or a higher optimization level is in
                     effect

                &lt;suboptions_list&gt; is a colon-separated list of one
                or more of the following:

                all | none
                     all disables all semantics-changing
                     transformations, including those controlled by
                     the ieeefp, order, library, precision, and
                     exceptions suboptions.  none enables these
                     transformations.
                precision | noprecision
                     precision disables all transformations that
                     are likely to affect floating-point precision,
                     including those controlled by the subnormals,
                     operationprecision, association,
                     reductionorder, and library suboptions.
                     noprecision enables these transformations.
                exceptions | noexceptions
                     exceptions disables all transformations likely
                     to affect exceptions or be affected by them,
                     including those controlled by the nans,
                     infinities, subnormals, guards, and library
                     suboptions. noexceptions enables these
                     transformations.
                ieeefp | noieeefp
                     ieeefp disables transformations that affect
                     IEEE floating-point compliance, including
                     those controlled by the nans, infinities,
                     subnormals, zerosigns, and operationprecision
                     suboptions. noieeefp enables these
                     transformations.
                nans | nonans
                     nans disables transformations that may produce
                     incorrect results in the presence of, or that
                     may incorrectly produce IEEE floating-point
                     signaling NaN (not-a-number) values. nonans
                     enables these transformations.
                infinities | noinfinities
                     infinities disables transformations that may
                     produce incorrect results in the presence of,
                     or that may incorrectly produce floating-point
                     infinities.  noinfinities enables these
                     transformations.
                subnormals | nosubnormals
                     subnormals disables transformations that may
                     produce incorrect results in the presence of,
                     or that may incorrectly produce IEEE
                     floating-point subnormals (formerly known as
                     denorms). nosubnormals enables these
                     transformations.
                zerosigns | nozerosigns
                     zerosigns disables transformations that may
                     affect or be affected by whether the sign of a
                     floating-point zero is correct. nozerosigns
                     enables these transformations.
                operationprecision | nooperationprecision
                     operationprecision disables transformations
                     that produce approximate results for
                     individual floating-point operations.
                     nooperationprecision enables these
                     transformations.
                order | noorder
                     order disables all code reordering between
                     multiple operations that may affect results or
                     exceptions, including those controlled by the
                     association, reductionorder, and guards
                     suboptions. noorder enables code reordering.
                association | noassociation
                     association disables reordering operations
                     within an expression. noassociation enables
                     reordering operations.
                reductionorder | noreductionorder
                     reductionorder disables parallelizing
                     floating-point reductions. noreductionorder
                     enables these reductions.
                guards | noguards
                     guards disables moving operations past guards
                     or calls which control whether the operation
                     should be executed or not. enables these
                     moving operations.
                library | nolibrary
                     library disables transformations that affect
                     floating-point library functions. nolibrary
                     enables these transformations.

</pre>
]]>
</flag>


<flag name="F-qlanglvl:extc99"
      class="compiler"
      regexp="-qlanglvl=extc99\b">
Allows most any c dialect.
</flag>


<flag name="F-D__extern_always_inline:inline"
      class="optimization"
      regexp="-D__extern_always_inline=inline\b">
Macro to have compiler always inline externs if specified.
</flag>


<!--
  -
  -	Other flags: compiler resource consumption.
  -
  -->

<flag name="F-qinline"
      class="optimization"
      regexp="-qinline=(\S+)\b">
<example>
-qinline=40
</example>
<![CDATA[
<p>
 The <tt>inline</tt> option  specifies the threshold and
 limit of inlined functions
</p>
]]>
</flag>

<flag name="F-qipa:inline"
      class="optimization"
      regexp="-qipa=inline=(\S+)\b">
<example>
-qipa=inline=limit=1000
-qipa=inline=threshold=100
</example>
<![CDATA[
<p>
 The <tt>inline</tt> suboption  specifies the threshold and
 limit of inlined functions
</p>
]]>
</flag>

<flag name="F-qipa:noobject"
      class="other"
      regexp="-qipa=noobject\b">
<example>
-qipa=noobject
</example>
<![CDATA[
<p>
 Specifies whether to include standard object code in the object files.
 The <tt>noobject</tt> suboption can substantially reduce overall
 compilation time, by not generating object code during the first IPA phase.
 This option does not affect the code in the final binary created.
</p>
]]>
</flag>

<flag name="F-qipa:partition"
      class="optimization"
      regexp="-qipa=partition=large\b">
<example>
-qipa=partition=large
</example>
<![CDATA[
<p>
 The <tt>partition</tt> suboption specifies the size of the program
 sections that are analysed together.  Larger partitons may produce
 better analysis but require more storage. Default is medium.
</p>
]]>
</flag>


<flag name="F-qipa:threads"
      class="optimization"
      regexp="-qipa=threads(=\d+)?\b">
<example>
-qipa=threads
</example>
<![CDATA[
<p>
 The <tt>threads</tt> suboption allows the IPA optimizer to run portions
 of the optimization process in parallel threads, which can speed up the
 compilation process on multi-processor systems. All the available
 threads, or the number specified by N, may be used. N must be a positive
 integer. Specifying <tt>nothreads</tt> does not run any parallel threads;
 this is equivalent to running one serial thread.
 This option does not affect the code in the final binary created.
</p>
]]>
</flag>


<flag name="F-qspillsize"
      class="other"
      regexp="-qspillsize=\d+\b">
<example>
-qspillsize=512,
-qspillsize=32648
</example>
<![CDATA[
<p>
Specifies the size of the compiler's internal program storage areas, in bytes.
</p>
]]>
</flag>



<!--
  -
  -	Other flags: error & warning messages.
  -
  -->

<flag name="F-qdebug:except"
      class="other"
      regexp="-qdebug=except\b">
Causes the compiler to output a traceback if it abends.
</flag>


<flag name="F-qsuppress"
      class="other"
      regexp="-qsuppress=([^:\s]+):(\S+)">
<example>-qsuppress=msg1:msg2</example>
<include text="-qsuppress=$2" />
<include text="-qsuppress=$1" />
<display enable="0" />
</flag>


<flag name="F-qsuppress:"
      class="other"
      regexp="-qsuppress=([^:\s]+)\b">
<example>
-qsuppress=1500-036,
-qsuppress=cmpmsg
</example>
Suppresses the message with the message number specified.
</flag>


<flag name="F-w"
      class="other"
      regexp="-w\b">
Suppresses informational, language-level, and warning messages. This option sets
-qflag=e:e.
</flag>

<flag name="F-ltcmalloc"
      class="optimization"
>
Link with tcmalloc's library for Linux on POWER. This is a library that
optimizes calls to new, delete, malloc and free.
</flag>


<flag name="F-lhugetlbfs"
      class="optimization"
>
Link with libhugetlbfs.so. This enables heap to be backed by the 16 Megabyte pages.
</flag>

<flag name="F-tl"
      class="optimization"
>
<![CDATA[
Applies the prefix specified by the -B option to the designated components.
<table>
<tr>
<th align="left">Parameter</th>
<th align="left">Description</th>
<th align="left">Executable name</th>
</tr>
<tr>
<td>a</td>
<td>Assembler</td>
<td>as</td>
</tr>
<tr>
<td>b</td>
<td>Low-level optimizer</td>
<td>xlfcode</td>
</tr>
<tr>
<td>c</td>
<td>Compiler front end</td>
<td>xlfentry</td>
</tr>
<tr>
<td>d</td>
<td>Disassembler</td>
<td>dis</td>
</tr>
<tr>
<td>F</td>
<td>C preprocessor</td>
<td>cpp</td>
</tr>
<tr>
<td>h</td>
<td>Array language optimizer</td>
<td>xlfhot</td>
</tr>
<tr>
<td>I</td>
<td>High-level optimizer, compile step</td>
<td>ipa</td>
</tr>
<tr>
<td>l</td>
<td>Linker</td>
<td>ld</td>
</tr>
<tr>
<td>z</td>
<td>Binder</td>
<td>bolt</td>
</tr>
</table>
]]>
</flag>

<flag name="link_whole_archive"
      class="optimization"
      regexp="-Wl,--whole-archive\s/\S*"
>
<example>
"-Wl,--wholearchive /usr/lib/libhugetlbfs.a"
</example>
Instructs the linker to include every object file in the specified library,
rather than searching the library for the required object files.
</flag>

<flag name="link_dl_static"
      class="optimization"
      regexp="/usr/lib/libdl.a"
>
<example>
"/usr/lib/libdl.a"
</example>
Instructs the linker to include libdl.a to enable dynamic linking loader.
</flag>

<flag name="link_no_whole_archive"
      class="optimization"
      regexp="-Wl,--no-whole-archive"
>
Turn off the effect of the --whole-archive flag. 
</flag>

<flag name="link_mul_defs" 
      class="optimization"
      regexp="-Wl,-z,muldefs"
>
Instructs the linker to allow multiple definitions and the first definition will
be used. Normally when a symbol is defined multiple times, the linker will report
a fatal error. 
</flag>

<flag name="hugetlbfs_BDT"
      class="optimization"
      regexp="-Wl,--hugetlbfs-link=BDT"
>
Pass the --hugetlbfs-link=BDT flag to the linker so that
the text, initialized data, and BSS segments of the application are backed by hugepages.
</flag>

<flag name="hugetlbfs_align"
      class="optimization"
      regexp="-Wl,--hugetlbfs-align"
>
Pass the --hugetlbfs-align flag to the linker so that we  can control 
(by environment variable HUGETLB_ELFMAP) which program segments are placed in hugepages.
</flag>

<flag name="F-B"
      class="optimization"
      regexp="-B/\S*"
>
<example>
-B/opt/at8.0/share/libhugetlbfs/
</example>
Determines substitute path names for XL Fortran executables such as the compiler, assembler, linker, and preprocessor.  It can be used in combination with the -t option, which determines which of these components are affected by -B.
</flag>

<flag name="link_emit_relocation"
      class="optimization"
      regexp="-Wl,-q\b"
>
Pass the -q flag to the linker causing the final executable to have the relocation information.
</flag>

<flag name="F-lstd8d"
      class="optimization"
>
Link with the Apache C++ Standard Library ("stdcxx"). "libstd8d.so" is a 32-bit shared library with optimization enabled.
</flag>


<flag name="Lstd"
      class="optimization"
      regexp="-L\s*[^ ]*stdcxx[^ ]*">
Adds the directory for the Apache C++ Standard Library to the search path at link time.
</flag>

<flag name="Rstd"
      class="optimization"
      regexp="-R\s*[^ ]*stdcxx[^ ]*">
<![CDATA[
<p>Specifies library search directory for the Apache C++ Standard Library for use by the runtime linker.  The information is recorded in the object file and passed to the runtime linker.</p>
]]>
</flag>


<!--
  -
  - Other flags: instrumentation & debugging.
  -
  -->

</flagsdescription>
